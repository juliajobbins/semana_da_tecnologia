<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pac-Man â€” Sakura Run</title>
  <style>
    :root{
      --bg:#0b1020; 
      --wall1:#f8c6d8; 
      --wall2:#ffd7e8; 
      --pellet:#ffc0cb; 
      --power:#ff7fbf; 
      --text:#fff;
      --tile:24px;
    }
    html,body{
      height:100%;
      margin:0;
      font-family:Inter, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      color:var(--text);
      background:linear-gradient(180deg,#071026 0%, #0b1630 100%);
    }
    .wrap{
      display:flex;
      gap:16px;
      align-items:flex-start;
      justify-content:center;
      padding:18px;}


    .ui{
      width:320px
    }
    h1{
      margin:0 0 10px;
      font-size:20px;
      letter-spacing:0.6px
    }
    .panel{
      background:linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
      padding:12px;border-radius:12px;box-shadow:0 6px 20px rgba(4,6,20,0.6);
    }
    canvas{
      background:linear-gradient(180deg,#071022, #021024);
      display:block;
      border-radius:10px;
      box-shadow:0 8px 30px rgba(2,6,16,0.7);
    }
    .meta{
      display:flex;
      gap:10px;align-items:center;
      justify-content:space-between;
      margin-top:8px}
    .score{
      font-weight:700
    }
    .small{
      font-size:13px;
      color:#dfe7ff99
    }
    .controls{
      margin-top:10px;font-size:13px
    }
    button{
      background:linear-gradient(180deg,#ff9ec9,#ff79b4);
      border:none;
      padding:12px 12px;
      border-radius:8px;
      color:#111;
      font-weight:700;
      cursor:pointer
    }
  
    .anime-btn {
      padding: 4px 14px;          /* altura menor, largura proporcional */
      font-size: 14px;             /* fonte menor */
      font-weight: 700;
      border-radius: 10px;         /* cantos arredondados */
      border: none;
      cursor: pointer;
      background: linear-gradient(180deg, #ff9ec9, #ff79b4); /* gradient rosa anime */
      color: #111;
      box-shadow: 0 4px 10px rgba(255, 105, 180, 0.4); /* sombra suave */
      transition: transform 0.1s, box-shadow 0.2s;
    }

    /* efeito hover e clique */
    .anime-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 14px rgba(255, 105, 180, 0.6);
    }
    .anime-btn:active {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(255, 105, 180, 0.4);
    }

    .back-btn {
      position: fixed;          /* fixa no canto da tela */
      top: 12px;
      left: 12px;
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #ff9ec9, #ff79b4);
      color: #111;
      font-size: 20px;
      font-weight: bold;
      text-decoration: none;
      border-radius: 50%;       /* deixa circular */
      box-shadow: 0 4px 10px rgba(255,105,180,0.4);
      transition: transform 0.1s, box-shadow 0.2s;
      z-index: 1000;            /* garante que fique acima do canvas */
      cursor: pointer;
    }

    .back-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 14px rgba(255,105,180,0.6);
    }

    .back-btn:active {
      transform: translateY(0);
      box-shadow: 0 4px 10px rgba(255,105,180,0.4);
    }


    footer{
      margin-top:10px;
      font-size:12px;
      color:#c7d7ff88
    }

  </style>
</head>
<body>
  <a href="index.html" class="back-btn" aria-label="Voltar">
    &#8592;
  </a>

  <div class="wrap">
    <div class="panel">
      <h1>PAC-MAN â€” SAKURA RUN ðŸŒ¸</h1>
      <div class="controls">Controles: setas / WASD â€” Colete todos os <strong>sakura-narutomaki</strong> para limpar a fase.</div>
      <div style="display:flex;gap:8px;margin-top:10px">
      <canvas id="game" width="616" height="616"></canvas>
      <div class="meta">
        <div>
          <div class="score">PontuaÃ§Ã£o: <span id="score">0</span></div>
          <div class="small">Vidas: <span id="lives">3</span></div>
        </div>
        <div>
          <div class="small">Fase: <span id="level">1</span></div>
        </div>
      </div>
      <div style="margin-top:12px; text-align:center;">
        <button id="restart" class="anime-btn">Reiniciar</button>
      </div>
  </div>

<script>
// --- Pac-Man simplificado com tema anime (com chasing ghosts, teletransporte lateral e restart funcional) ---

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');
const scoreEl = document.getElementById('score');
const livesEl = document.getElementById('lives');
const levelEl = document.getElementById('level');
const restartBtn = document.getElementById('restart');

const TILE = 28; // grid tile size
const COLS = 21; // keep odd to center
const ROWS = 21;
const WIDTH = COLS*TILE;
const HEIGHT = ROWS*TILE;
canvas.width = WIDTH; canvas.height = HEIGHT;

// Map legend: 0 wall, 1 pellet, 2 empty, 3 power-pellet
const MAP_TEMPLATE = [
  "000000000000000000000",
  "011111111111111111110",
  "010001000010001000010",
  "013011111111111100310",
  "010001000010001000010",
  "011111111111111111110",
  "010001010000010100010",
  "011111010111010111110",
  "000101010010010101000",
  "111111111111111111111",
  "000101010010010101000",
  "011111010111010111110",
  "010001010000010100010",
  "011111111111111111110",
  "010001000010001000010",
  "013011111111111100310",
  "010001000010001000010",
  "011111111111111111110",
  "000000000000000000000",
  "000000000000000000000",
  "000000000000000000000",
];

let map = [];
function loadMap(){
  map = [];
  for(let r=0;r<ROWS;r++){
    const row = [];
    const line = MAP_TEMPLATE[r] || ''.padEnd(COLS,'0');
    for(let c=0;c<COLS;c++){
      const ch = line[c]||'0';
      if(ch==='0') row.push(0);
      else if(ch==='1') row.push(1);
      else if(ch==='2') row.push(2);
      else if(ch==='3') row.push(3);
      else row.push(0);
    }
    map.push(row);
  }
}

// Player (Pac-kawaii)
const player = {
  x: 10.5, y: 15.5, // grid coords (centered)
  dir: {x:0,y:0}, nextDir:{x:0,y:0}, speed:0.12, radius: TILE*0.45
};

// Ghosts
const ghostColors = ['#ff6b6b','#6b8cff','#ffd36b','#9b6bff'];
let ghosts = [];
function resetGhosts(){
  ghosts = [
    {x:10.5,y:9.5,dir:{x:0,y:0},speed:0.08,scatter:true,color:ghostColors[0],vulnerable:false},
    {x:9.5,y:9.5,dir:{x:0,y:0},speed:0.075,scatter:true,color:ghostColors[1],vulnerable:false},
    {x:11.5,y:9.5,dir:{x:0,y:0},speed:0.07,scatter:true,color:ghostColors[2],vulnerable:false},
    {x:10.5,y:8.5,dir:{x:0,y:0},speed:0.065,scatter:true,color:ghostColors[3],vulnerable:false}
  ];
}

let score=0,lives=3,level=1;let gameOver=false;let pelletsLeft=0;let powerMode=false;let powerTimer=0;

// --- NEW: ghost mode scheduler (alternates between scatter and chase) ---
let ghostMode = 'scatter'; // 'scatter' or 'chase'
let ghostModeTimer = 0; // frames / normalized (we'll use seconds scaled to dt)
const MODE_CYCLE = [
  {mode:'scatter',duration:5}, // seconds
  {mode:'chase',duration:20},  // seconds
  {mode:'scatter',duration:5},
  {mode:'chase',duration:20}
];
let modeIndex = 0;
function setGhostMode(m){
  ghostMode = m;
  // mark ghosts' scatter flag (used for some behaviors if needed)
  ghosts.forEach(g=>g.scatter = (m==='scatter'));
}

// initialize mode timer
function initGhostMode(){
  modeIndex = 0;
  ghostModeTimer = MODE_CYCLE[0].duration * 60; // convert seconds -> ~frames (since dtâ‰ˆ1 per frame)
  setGhostMode(MODE_CYCLE[0].mode);
}

// Helper: map tile queries
function isWallTile(c,r){ if(r<0||r>=ROWS||c<0||c>=COLS) return true; return map[r][c]===0; }
function tileAt(x,y){ const c=Math.floor(x);const r=Math.floor(y); if(r<0||r>=ROWS||c<0||c>=COLS) return 0; return map[r][c]; }
function isWallAt(x,y){ const c=Math.floor(x);const r=Math.floor(y); if(r<0||r>=ROWS||c<0||c>=COLS) return true; return map[r][c]===0; }

// Movement and collisions
function tryTurn(){
  if(player.nextDir.x===0 && player.nextDir.y===0) return;

  // First: if player is stopped (dir = 0), allow immediate movement if the next tile is free
  const testNx = player.x + player.nextDir.x * 0.5;
  const testNy = player.y + player.nextDir.y * 0.5;
  // handle wrap test for immediate movement
  if((player.dir.x === 0 && player.dir.y === 0) && !isWallAt(testNx,testNy)){
    player.dir = {...player.nextDir};
    player.nextDir = {x:0,y:0};
    return;
  }

  // Otherwise, only allow turning when sufficiently centered on the perpendicular axis (classic Pac-Man behavior)
  const roundedX = Math.abs(player.x - Math.round(player.x))<0.15;
  const roundedY = Math.abs(player.y - Math.round(player.y))<0.15;
  if((player.nextDir.x!==0 && roundedY) || (player.nextDir.y!==0 && roundedX)){
    const nx = player.x + player.nextDir.x*0.5;
    const ny = player.y + player.nextDir.y*0.5;
    if(!isWallAt(nx,ny)){
      player.dir = {...player.nextDir};
      player.nextDir={x:0,y:0};
    }
  }
}

// helper to test whether we can wrap horizontally to other side at a given row
function canWrapToRowCol(row, col){ // col may be negative or >=COLS
  const wrappedC = ((col % COLS) + COLS) % COLS;
  if(row<0||row>=ROWS) return false;
  return map[row][wrappedC] !== 0;
}

function movePlayer(dt){
  tryTurn();
  // dt is normalized to ~1 for 60fps (see loop). Use it directly.
  let nx = player.x + player.dir.x * player.speed * dt;
  let ny = player.y + player.dir.y * player.speed * dt;

  // Handle horizontal wrap (teletransporte lateral) if moving beyond edges
  if(nx < 0 || nx >= COLS){
    const targetRow = Math.floor(ny);
    const wrappedCol = nx < 0 ? COLS-1 : 0;
    if(canWrapToRowCol(targetRow, wrappedCol)){
      // teleport player to other side keeping small offset so movement continues smoothly
      player.x = nx < 0 ? COLS - 0.001 : 0.001;
      player.y = ny;
    } else {
      // can't wrap (wall on other side) => block movement
      // do nothing, keep player in place
    }
  } else {
    // normal movement without wrapping
    if(!isWallAt(nx, ny)){
      player.x = nx; player.y = ny;
    } else {
      // collision with wall -> stop movement (do nothing)
    }
  }

  // collect pellets
  const r = Math.floor(player.y); const c = Math.floor(player.x);
  if(map[r] && (map[r][c]===1 || map[r][c]===3)){
    if(map[r][c]===1){ score += 10; }
    else if(map[r][c]===3){ score += 50; powerMode=true; powerTimer=600; // frames (~10s)
      // make ghosts vulnerable
      ghosts.forEach(g=>g.vulnerable=true);
    }
    map[r][c]=2; pelletsLeft--; updateUI();
    // small sound
    playBeep(1200,0.03);
  }
}

// Ghost AI: random walker + chase mode
function moveGhost(g, dt) {
  const dirs = [
    {x: 1, y: 0},   // direita
    {x: -1, y: 0},  // esquerda
    {x: 0, y: 1},   // baixo
    {x: 0, y: -1}   // cima
  ];

  const tileSize = 1;
  const margin = 0.25;
  const centeredX = Math.abs((g.x % tileSize) - tileSize / 2) < margin || Math.abs(g.x % tileSize) < margin;
  const centeredY = Math.abs((g.y % tileSize) - tileSize / 2) < margin || Math.abs(g.y % tileSize) < margin;
  const canTurn = centeredX && centeredY;

  // --- comportamento por cor ---
  let chaseRange = 6;
  let changeChance = 0.02;
  let speedFactor = 1;
  switch (g.color) {
    case "#ff6b6b": // vermelho raivoso
      chaseRange = 9; changeChance = 0.01; speedFactor = 1.3; break;
    case "#ffd36b": // amarelo aleatÃ³rio
      chaseRange = 3; changeChance = 0.05; speedFactor = 1; break;
    case "#9b6bff": // roxo perseguidor
      chaseRange = 8; changeChance = 0.02; speedFactor = 1.1; break;
    case "#6b8cff": // azul lento
      chaseRange = 5; changeChance = 0.03; speedFactor = 0.8; break;
  }

  // --- funÃ§Ã£o auxiliar: dentro da casinha ---
  function inGhostHouse(g) {
    return g.x >= 9 && g.x <= 11 && g.y >= 8 && g.y <= 10;
  }

  // --- direÃ§Ã£o inicial lateral (se parado) ---
  if (!g.dir || (g.dir.x === 0 && g.dir.y === 0)) {
    const sideDirs = [{x:1,y:0},{x:-1,y:0}];
    const validDirs = sideDirs.filter(d => !isWallAt(g.x + d.x, g.y + d.y));
    if (validDirs.length) g.dir = validDirs[Math.floor(Math.random() * validDirs.length)];
    else {
      const validDirs2 = dirs.filter(d => !isWallAt(g.x + d.x, g.y + d.y));
      if(validDirs2.length) g.dir = validDirs2[Math.floor(Math.random() * validDirs2.length)];
    }
  }

  // --- decisÃ£o de direÃ§Ã£o ---
  if (canTurn && (!g.lastTurnTime || performance.now() - g.lastTurnTime > 250)) {
    g.lastTurnTime = performance.now();

    if (!inGhostHouse(g) && !powerMode) {
      // perseguir se perto
      const dx = player.x - g.x;
      const dy = player.y - g.y;
      const dist2 = dx*dx + dy*dy;

      if(dist2 < chaseRange*chaseRange){
        const validDirs = dirs.filter(d => !isWallAt(g.x + d.x, g.y + d.y));
        if(validDirs.length){
          let bestDir = g.dir; let bestDist = Infinity;
          for(const d of validDirs){
            const nx = g.x + d.x; const ny = g.y + d.y;
            const newDist = (nx - player.x)**2 + (ny - player.y)**2;
            if(newDist < bestDist){ bestDist = newDist; bestDir = d; }
          }
          g.dir = bestDir;
        }
      }
    } else {
      // andar aleatÃ³rio
      if (!g.dir || Math.random() < changeChance) {
        const validDirs = dirs.filter(d=>{
          if(g.dir && d.x === -g.dir.x && d.y === -g.dir.y) return false; // nÃ£o volta atrÃ¡s
          return !isWallAt(g.x + d.x, g.y + d.y);
        });
        if(validDirs.length){
          g.dir = validDirs[Math.floor(Math.random()*validDirs.length)];
        }
      }
    }
  }

  // --- movimento contÃ­nuo ---
  if(g.dir){
    const nx = g.x + g.dir.x * g.speed * speedFactor * dt;
    const ny = g.y + g.dir.y * g.speed * speedFactor * dt;
    if(!isWallAt(nx,ny)){
      g.x = nx; g.y = ny;
    } else {
      // se bateu em parede, tenta nova direÃ§Ã£o lateral vÃ¡lida
      const lateralDirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}].filter(d=>!isWallAt(g.x + d.x, g.y + d.y));
      if(lateralDirs.length) g.dir = lateralDirs[Math.floor(Math.random()*lateralDirs.length)];
    }
  }
}

function checkCollisions(){
  ghosts.forEach(g=>{
    const dx = g.x - player.x; const dy = g.y - player.y; const dist2 = dx*dx + dy*dy;
    if(dist2 < 0.35){
      if(powerMode && g.vulnerable){
        // eat ghost
        score += 200; // bonus
        // send ghost back to home
        g.x = 10.5; g.y = 9.5; g.vulnerable=false; g.dir = {x:0,y:0};
        playBeep(600,0.05);
      } else {
        // lose life
        loseLife();
      }
      updateUI();
    }
  });
}

function loseLife(){
  lives--; playBeep(200,0.15); if(lives<=0){ gameOver=true; }
  // reset positions
  player.x=10.5; player.y=15.5; player.dir={x:0,y:0}; player.nextDir={x:0,y:0};
  resetGhosts();
  // when life lost, reset ghost mode cycle to start scatter
  initGhostMode();
}

// Drawing helpers (anime-style)
function drawWall(x,y){
  const px = x*TILE; const py = y*TILE;
  const g = ctx.createLinearGradient(px,py,px+TILE,py+TILE);
  g.addColorStop(0,'#ffd7e8'); g.addColorStop(1,'#f8c6d8');
  ctx.fillStyle=g; ctx.fillRect(px+2,py+2,TILE-4,TILE-4);
  ctx.fillStyle='#ff89b6';
  ctx.beginPath(); ctx.ellipse(px+TILE*0.25,py+TILE*0.25,2,3,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(px+TILE*0.7,py+TILE*0.6,2,3,0,0,Math.PI*2); ctx.fill();
}

function drawPellet(x,y){
  const px = x*TILE + TILE/2; const py = y*TILE + TILE/2;
  ctx.save(); ctx.translate(px,py);
  ctx.beginPath(); ctx.arc(0,0,3,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
  ctx.beginPath(); ctx.moveTo(0,-2); ctx.arc(0,0,2, -Math.PI/2, Math.PI*3/2); ctx.fillStyle='#ff5ea3'; ctx.fill();
  ctx.restore();
}
function drawPower(x,y){
  const px = x*TILE + TILE/2; const py = y*TILE + TILE/2;
  ctx.save(); ctx.translate(px,py);
  ctx.beginPath(); ctx.arc(0,0,7,0,Math.PI*2); ctx.fillStyle='#ffb6db'; ctx.fill();
  ctx.fillStyle='#fff'; ctx.font='10px serif'; ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText('ðŸ¥',0,0);
  ctx.restore();
}

function drawPlayer(){
  const px = player.x * TILE; const py = player.y * TILE;
  ctx.beginPath(); ctx.arc(px,py,player.radius*0.9,0,Math.PI*2); ctx.fillStyle='#ffef6b'; ctx.fill();
  ctx.fillStyle='#222'; ctx.beginPath(); ctx.ellipse(px-6,py-4,4,6,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(px+6,py-4,4,6,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.ellipse(px-5,py-6,1.5,2.5,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(px+7,py-6,1.5,2.5,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#ffb0c0'; ctx.beginPath(); ctx.ellipse(px-9,py+4,3,2,0,0,Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(px+9,py+4,3,2,0,0,Math.PI*2); ctx.fill();
}

function drawGhost(g){
  const px = g.x*TILE; const py = g.y*TILE;
  const w = TILE*0.9; const h = TILE*0.9;
  ctx.save(); ctx.translate(px,py);
  ctx.beginPath(); ctx.moveTo(-w/2,h/6); ctx.arc(0,-h/6,w/2,Math.PI,2*Math.PI); ctx.lineTo(w/4,h/2); ctx.quadraticCurveTo(0,h/3,-w/4,h/2); ctx.closePath();
  ctx.fillStyle = g.vulnerable ? '#bce7ff' : g.color; ctx.fill();
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.ellipse(-6, -2, 5, 7, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(6, -2, 5, 7, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle='#222'; ctx.beginPath(); ctx.ellipse(-6, -1, 2.5, 3.5, 0, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.ellipse(6, -1, 2.5, 3.5, 0, 0, Math.PI*2); ctx.fill();
  ctx.fillStyle='#ff6b6b'; ctx.fillRect(-3,6,6,2);
  ctx.restore();
}

// Audio (tiny beeps)
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
function playBeep(freq,vol){
  try{
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type='sine'; o.frequency.value = freq; g.gain.value = vol; o.connect(g); g.connect(audioCtx.destination); o.start();
    setTimeout(()=>{ o.stop(); },80);
  }catch(e){}
}

// Main loop
let last = performance.now();
function loop(now){
  // normalize delta to ~1 = one frame at 60fps
  const ms = Math.min(60, now - last);
  const dt = ms / (1000 / 60); // dt â‰ˆ 1 when frame delta ~16.66ms
  last = now;

  if(!gameOver){
    update(dt);
    render();
    requestAnimationFrame(loop);
  } else {
    render();
    ctx.fillStyle='rgba(0,0,0,0.6)'; ctx.fillRect(0,HEIGHT/2-40,WIDTH,80);
    ctx.fillStyle='#fff'; ctx.font='28px sans-serif'; ctx.textAlign='center'; ctx.fillText('Game Over â€” SAKURA RUN', WIDTH/2, HEIGHT/2);
    // Show hint to click Reiniciar (button already visible in UI)
  }
}

function update(dt){
  // update ghost global mode timer
  ghostModeTimer -= dt;
  if(ghostModeTimer <= 0){
    // advance cycle
    modeIndex = (modeIndex + 1) % MODE_CYCLE.length;
    ghostModeTimer = MODE_CYCLE[modeIndex].duration * 60;
    setGhostMode(MODE_CYCLE[modeIndex].mode);
  }

  movePlayer(dt);
  ghosts.forEach(g=>moveGhost(g,dt));
  checkCollisions();
  if(powerMode){ powerTimer -= dt; if(powerTimer<=0){ powerMode=false; ghosts.forEach(g=>g.vulnerable=false); }}
  if(pelletsLeft<=0){ // next level
    level++; levelEl.textContent = level; loadMap(); pelletsLeft=0; for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(map[r][c]===1||map[r][c]===3) pelletsLeft++;
    player.x=10.5; player.y=15.5; resetGhosts();
    initGhostMode();
  }
}

function render(){
  ctx.clearRect(0,0,WIDTH,HEIGHT);
  const bg = ctx.createLinearGradient(0,0,0,HEIGHT);
  bg.addColorStop(0,'#071022'); bg.addColorStop(1,'#00121f'); ctx.fillStyle=bg; ctx.fillRect(0,0,WIDTH,HEIGHT);

  // draw map
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const v = map[r][c];
      if(v===0) drawWall(c,r);
      else if(v===1) drawPellet(c,r);
      else if(v===3) drawPower(c,r);
    }
  }
  // decorative sakura petals
  for(let i=0;i<7;i++){ ctx.fillStyle='rgba(255,140,180,0.05)'; ctx.beginPath(); ctx.ellipse( (i*97)%WIDTH, (i*61)%HEIGHT, 6,3, Math.sin((Date.now()/600+i)/2),0,Math.PI*2); ctx.fill(); }

  // draw ghosts & player
  ghosts.forEach(g=>drawGhost(g));
  drawPlayer();
}

// Input
window.addEventListener('keydown',e=>{
  const key = e.key.toLowerCase();
  if(key === 'arrowleft' || key === 'a'){ player.nextDir={x:-1,y:0}; e.preventDefault(); }
  else if(key === 'arrowright' || key === 'd'){ player.nextDir={x:1,y:0}; e.preventDefault(); }
  else if(key === 'arrowup' || key === 'w'){ player.nextDir={x:0,y:-1}; e.preventDefault(); }
  else if(key === 'arrowdown' || key === 's'){ player.nextDir={x:0,y:1}; e.preventDefault(); }

  // resume audio context if needed
  if(audioCtx.state==='suspended') audioCtx.resume();
});

// Restart logic: reset everything and restart the loop (works when gameOver true or during play)
restartBtn.addEventListener('click',()=>{ restart(); });

function updateUI(){ scoreEl.textContent = score; livesEl.textContent = lives; levelEl.textContent = level; }

function init(){
  loadMap();
  // count pellets
  pelletsLeft=0;
  for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(map[r][c]===1||map[r][c]===3) pelletsLeft++;
  player.x=10.5;player.y=15.5;player.dir={x:0,y:0};player.nextDir={x:0,y:0};
  resetGhosts();
  score=0;lives=3;level=1;gameOver=false;powerMode=false;powerTimer=0;
  updateUI();
  initGhostMode();
  last = performance.now(); // reset timing
  requestAnimationFrame(loop);
}

function restart(){
  loadMap();
  pelletsLeft=0;for(let r=0;r<ROWS;r++) for(let c=0;c<COLS;c++) if(map[r][c]===1||map[r][c]===3) pelletsLeft++;
  player.x=10.5;player.y=15.5;player.dir={x:0,y:0};player.nextDir={x:0,y:0};
  resetGhosts();score=0;lives=3;gameOver=false;powerMode=false;powerTimer=0;updateUI();
  initGhostMode();
  last = performance.now();
  // ensure the loop restarts if it was stopped by gameOver
  requestAnimationFrame(loop);
}

// start
init();

</script>
</body>
</html>
